# ASSIGNMENT: Sampling and Reproducibility in Python

Read the blog post [Contact tracing can give a biased sample of COVID-19 cases](https://andrewwhitby.com/2020/11/24/contact-tracing-biased/) by Andrew Whitby to understand the context and motivation behind the simulation model we will be examining.

Examine the code in `whitby_covid_tracing.py`. Identify all stages at which sampling is occurring in the model. Describe in words the sampling procedure, referencing the functions used, sample size, sampling frame, any underlying distributions involved, and how these relate to the procedure outlined in the blog post.

Run the Python script file called whitby_covid_tracing.py as is and compare the results to the graphs in the original blog post. Does this code appear to reproduce the graphs from the original blog post?

Modify the number of repetitions in the simulation to 100 (from the original 1000). Run the script multiple times and observe the outputted graphs. Comment on the reproducibility of the results.

Alter the code so that it is reproducible. Describe the changes you made to the code and how they affected the reproducibility of the script file. The output does not need to match Whitbyâ€™s original blogpost/graphs, it just needs to produce the same output when run multiple times

# Author: Chaoran Dong

```
The first stage uses simple random sampling without replacement to determine who becomes infected. The sampling frame includes the 1000 individuals at events, consisting of 200 from weddings and 800 from brunches. The sample size is 100 individuals, based on an attack rate of 0.1. Sampling is performed using the np.random.choice function, which follows a uniform distribution. This means every individual among the 1000 has an equal probability of being selected for infection, resulting in a total of exactly 100 infected individuals, calculated as int(len(ppl) * ATTACK_RATE). This approach reflects the procedure described in the blog, where exactly 10% of people across all events are infected, regardless of the event type.
The second stage corresponds to the primary contact tracing described in the blog post, where each infected individual has a 20% probability of being traced. This stage follows a Bernoulli sampling process, resulting in a Bernoulli-distributed outcome with a probability of success equal to 0.2, represented by TRACE_SUCCESS. The sampling frame consists of the infected individuals, totaling 100. The sample size is variable, with an expected value of 20. The function used is np.random.rand, which generates random values between 0 and 1 for each infected individual. These values are then compared to the tracing probability to determine whether each individual is traced.
The third stage represents the secondary contact tracing step, which assumes that if two infections are identified from the same event, everyone who attended that event will be traced. This leads to the identification of all infections associated with that event. The sampling in this stage is cluster-based but not probability sampling, as individuals are selected based on an event-level threshold rather than through a random draw. The sampling frame consists of all attendees at events that are flagged for secondary tracing, and the sample size includes all attendees of those flagged events. The function event_trace_counts identifies all events with at least two infections detected through primary tracing. Then, ppl.loc is used to find all infected individuals in those events and mark them as traced. It is worth noting that while the code applies this step only to infected individuals, the blog suggests that the sampling frame and sample size should include all attendees of the flagged events.
The final step, which involves running the simulation function 1000 times, is also a sampling process. In this case, the sampling frame is the space of all possible outcomes generated by the simulation, and the sample size is 1000. The function used is [simulate_event(m) for m in range(1000)], which corresponds to the step in the blog where the distribution of the proportion of infections attributed to weddings is generated.
After running the Python script, the generated graph did not reproduce the results shown in the original blog. In particular, the red curve representing the observed proportion centers around 0.2 in my graph, whereas in the blog, it is centered closer to 0.5. In other words, the blog shows a clear deviation between the true and observed proportions, both in their central tendency and density. In contrast, my generated graph shows the true and observed proportions largely overlapping, with both centered near 0.2.
There may be two reasons for the difference. First, in the Python script, the event sizes for weddings and brunches are not distinguished. All weddings are treated as a single event, and all brunches are treated as another single event. As a result, during secondary tracing, both event types are frequently flagged, rather than identifying more wedding events due to their larger size. Second, the script infects exactly 10 percent of the population, while the blog assigns each individual an independent 10 percent probability of being infected, following a Bernoulli process. This introduces additional randomness.
After modifying the number of repetitions to 100 and running the script multiple times, I observed that the overall shape of the graphs remained similar. The blue bars consistently peaked near 0.2, and the red bars were slightly shifted to the right. However, the exact position, height, and spread of the bar plots varied between runs. 
To make the script reproducible, I added the line np.random.seed(123) at the top of the file, after the import statements. Setting a random seed ensures that the random processes used in the simulation generate the same output each time the script is executed.


```


## Criteria

|Criteria|Complete|Incomplete|
|--------|----|----|
|Altercation of the code|The code changes made, made it reproducible.|The code is still not reproducible.|
|Description of changes|The author explained the reasonings for the changes made well.|The author did not explain the reasonings for the changes made well.|

## Submission Information

ðŸš¨ **Please review our [Assignment Submission Guide](https://github.com/UofT-DSI/onboarding/blob/main/onboarding_documents/submissions.md)** ðŸš¨ for detailed instructions on how to format, branch, and submit your work. Following these guidelines is crucial for your submissions to be evaluated correctly.

### Submission Parameters:
* Submission Due Date: `23:59 - 09/04/2025`
* The branch name for your repo should be: `assignment-1`
* What to submit for this assignment:
    * This markdown file (a1_sampling_and_reproducibility.md) should be populated.
    * The `whitby_covid_tracing.py` should be changed.
* What the pull request link should look like for this assignment: `https://github.com/<your_github_username>/sampling/pull/<pr_id>`
    * Open a private window in your browser. Copy and paste the link to your pull request into the address bar. Make sure you can see your pull request properly. This helps the technical facilitator and learning support staff review your submission easily.

Checklist:
- [ ] Create a branch called `assignment-1`.
- [ ] Ensure that the repository is public.
- [ ] Review [the PR description guidelines](https://github.com/UofT-DSI/onboarding/blob/main/onboarding_documents/submissions.md#guidelines-for-pull-request-descriptions) and adhere to them.
- [ ] Verify that the link is accessible in a private browser window.

If you encounter any difficulties or have questions, please don't hesitate to reach out to our team via the help channel in Slack. Our Technical Facilitators and Learning Support staff are here to help you navigate any challenges.
